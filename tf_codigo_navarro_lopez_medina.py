# -*- coding: utf-8 -*-
"""TF_Codigo_Navarro_Lopez_Medina.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PHYX5d2e-hVln-IOd9vw8w-8wlUJ5jr8

#Trabajo Final:

Integrantes:
- Juan Jose Navarro.
- Jose Lopez.
- Yoel Medina.
"""

import networkx as nx
from networkx.algorithms.community import girvan_newman
import warnings
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import math
warnings.filterwarnings('ignore')

#Carga de nodos y aristas
nodos_df = pd.read_csv("nodos_sunat.csv", encoding='latin-1', sep=",")
edges_df = pd.read_csv("partidas_sunat2.csv", encoding='latin-1', sep=",")

#Creamos el Grafo
rutas = nx.DiGraph()

#Añadir los nodos
for index, row in nodos_df.iterrows():
    rutas.add_node(row['id'], nodo=row['nodo'], tipo=row['tipo'], manif=row['manifiestos'], empresa=row['empresa'])

#Añadir las aristas
for index, row in edges_df.iterrows():
    source = row['id_ini']
    target = row['id_fin']
    containers = row['containers']
    viajes = row['viajes']
    conxviaj = row ['conxviaj']

    rutas.add_edge(source, target, weight=conxviaj, containers=containers, viajes=viajes)

# a. ¿Cuántos puertos y viajes están representados en el grafo?

nodos = rutas.number_of_nodes()
aristas = rutas.number_of_edges()

# Mostrar el número de nodos y aristas
print(f"Número de puertos: {nodos}")
print(f"Número de viajes: {aristas}")

nx.is_directed(rutas)

#Visualizar todos los atributos de los nodos de un grafo
for k,v in rutas.nodes(data=True):
    print(k,v)

#Dibujamos el Grafo
total_naves = sum(1 for nodo, atributos in rutas.nodes(data=True) if atributos.get("tipo") == "NAVE")
total_puertos = sum(1 for nodo, atributos in rutas.nodes(data=True) if atributos.get("tipo") == "PUERTO")

print("Número de nodos en el grafo:", rutas.number_of_nodes(), "(Naves: ",total_naves, ", Puertos: ",total_puertos, ")")
print("Número de bordes en el grafo:", rutas.number_of_edges())

#Utilizar el diseno spring_layout para el parametro pos
pos = nx.spring_layout(rutas)

plt.figure(figsize=(20,10))
plt.axis('off')

colores = ['red' if rutas.nodes[nodo]['tipo'] == 'NAVE' else 'blue' for nodo in rutas.nodes]
nx.draw_networkx_nodes(rutas, pos, node_size=20, node_color=colores)
nx.draw_networkx_edges(rutas, pos, alpha=.1)

plt.show()

"""##Grados de los nodos

Visualización del grafo, con los tamaños de los nodos proporcionales a los grados de cada nodo
"""

#Calculo de grados de los nodos
grados = dict(rutas.degree())

# Calcula los tamaños de los nodos proporcionales a sus grados
tamaños = [v * 10 for v in grados.values()]

#Utilizar el diseno spring_layout para el parametro pos
pos = nx.spring_layout(rutas)

plt.figure(figsize=(20,10))
plt.axis('off')

colores = ['red' if rutas.nodes[nodo]['tipo'] == 'NAVE' else 'blue' for nodo in rutas.nodes]
nx.draw_networkx_nodes(rutas, pos, node_size=tamaños, node_color=colores)
nx.draw_networkx_edges(rutas, pos, alpha=.1)

plt.show()

# Filtra los nodos por tipo
nodos_nave = [(nodo, rutas.nodes[nodo]['nodo']) for nodo, tipo in rutas.nodes(data='tipo') if tipo == 'NAVE']
nodos_puerto = [(nodo, rutas.nodes[nodo]['nodo']) for nodo, tipo in rutas.nodes(data='tipo') if tipo == 'PUERTO']

# Ordena los nodos por grado
nodos_nave.sort(key=lambda x: grados[x[0]], reverse=True)
nodos_puerto.sort(key=lambda x: grados[x[0]], reverse=True)

# Imprime los top 10 de naves y puertos con mayor grado
print("Top 10 de Naves:")
for i, (nodo, nombre) in enumerate(nodos_nave[:10]):
    print(f"{i+1}. Nodo: {nodo}, Nombre: {nombre}, Grado: {grados[nodo]}")

print("\nTop 10 de Puertos:")
for i, (nodo, nombre) in enumerate(nodos_puerto[:10]):
    print(f"{i+1}. Nodo: {nodo}, Nombre: {nombre}, Grado: {grados[nodo]}")

"""Visualización del grafo, resaltando a las naves de la empresa analizada"""

# Creamos una lista de nodos que pertenecen a la empresa "MSC"
nodos_msc = [nodo for nodo, datos in rutas.nodes(data=True) if 'empresa' in datos and datos['empresa'] == '3402- MEDITERRANEAN SHIPPING COMPANY DEL PERU SAC']

#Dibujamos el Grafo
total_naves = sum(1 for nodo, atributos in rutas.nodes(data=True) if atributos.get("tipo") == "NAVE")
total_puertos = sum(1 for nodo, atributos in rutas.nodes(data=True) if atributos.get("tipo") == "PUERTO")

print("Número de nodos en el grafo:", rutas.number_of_nodes(), "(Naves: ",total_naves, ", Puertos: ",total_puertos, ")")
print("Número de bordes en el grafo:", rutas.number_of_edges())

#Utilizar el diseno spring_layout para el parametro pos
pos = nx.spring_layout(rutas)

plt.figure(figsize=(20,10))
plt.axis('off')

colores = ['red' if rutas.nodes[nodo]['tipo'] == 'NAVE' else 'blue' for nodo in rutas.nodes]
nx.draw_networkx_nodes(rutas, pos, node_size=20, node_color=colores)
nx.draw_networkx_nodes(rutas, pos, node_size=20, nodelist=nodos_msc, node_color='green')
nx.draw_networkx_edges(rutas, pos, alpha=.1)

plt.show()

"""## Ponderación del Grafo

###Ponderación por containers

Se realizará la visualización del grafo de acuerdo a la ponderación, cabe indicar que se la ponderación elegida es el número de containers que recibe cada uno de los nodos entre los pares de aristas.

Se han determinado cuatro categorías de acuerdo al núnmero de containers descargados:

* Categoria 1: 1 contenedor.
* Categoría 2: Entre 2 y 50 contenedores.
* Categoría 3: Entre 50 y 500 contenedores.
* Categoría 4: 500 contenedores a más.
"""

# Asigna los pesos del grafo 'rutas' basados en el número de containers en las aristas
for u, v, data in rutas.edges(data=True):
    rutas[u][v]['weight'] = data['containers']

# Define los rangos de categorías de peso
categorias = {
    1: [1],
    2: list(range(2, 51)),
    3: list(range(51, 501)),
    4: list(range(501, 10000))
}

# Asigna colores a las categorías
color_map = {
    1: 'blue',
    2: 'green',
    3: 'yellow',
    4: 'red'
}

# Asigna un color a cada arista según la categoría de su peso
edge_colors = []
for u, v, data in rutas.edges(data=True):
    peso = data['weight']
    for categoria, rango in categorias.items():
        if peso in rango:
            edge_colors.append(color_map[categoria])
            break

# Dibuja los nodos
pos = nx.spring_layout(rutas)  # Posiciones de los nodos

plt.figure(figsize=(20,10))
plt.axis('off')

nx.draw_networkx_nodes(rutas, pos, node_size=20, node_color=colores)

# Dibuja las aristas con colores según las categorías de pesos
nx.draw_networkx_edges(rutas, pos, edge_color=edge_colors, width=.5, alpha=.1)

# Crea leyendas para las categorías
legend_colors = [plt.Line2D([0], [0], color=color, lw=2, label=f'Categoría {cat}') for cat, color in color_map.items()]
plt.legend(handles=legend_colors)

"""###Ponderación de acuerdo al indicador de containers por viaje

Se categorizará en 4 diferentes clases dependiendo del número de containers por viaje, ya que dicha variable muestra de forma relativa el número total de containers transportados.

* Categoria 1: 1 contenedor por viaje.
* Categoría 2: Entre 2 y 20 contenedores por viaje.
* Categoría 3: Entre 21 y 500 contenedores por viaje.
* Categoría 4: 500 contenedores por viaje a más.
"""

# Se realizará la ponderación de las aristas de acuerdo al número de containers desembarcados por manifiesto

# Acceder a los pesos de las aristas
weights = nx.get_edge_attributes(rutas, 'weight')
print(weights)

#Generación del archivo Graphml para importarlo a Gephi
nx.write_graphml(rutas,'rutas.graphml')

# Asigna los pesos del grafo 'rutas' basados en el número de containers en las aristas
for u, v, data in rutas.edges(data=True):
    rutas[u][v]['weight'] = data['weight']

# Define los rangos de categorías de peso
categorias = {
    1: [1],
    2: list(range(2, 21)),
    3: list(range(21, 501)),
    4: list(range(501, 10000))
}

# Asigna colores a las categorías
color_map = {
    1: 'blue',
    2: 'green',
    3: 'yellow',
    4: 'red'
}

# Asigna un color a cada arista según la categoría de su peso
edge_colors = []
for u, v, data in rutas.edges(data=True):
    peso = data['weight']
    for categoria, rango in categorias.items():
        if peso in rango:
            edge_colors.append(color_map[categoria])
            break

# Dibuja los nodos
pos = nx.spring_layout(rutas)  # Posiciones de los nodos

plt.figure(figsize=(20,10))
plt.axis('off')

nx.draw_networkx_nodes(rutas, pos, node_size=20, node_color=colores)

# Dibuja las aristas con colores según las categorías de pesos
nx.draw_networkx_edges(rutas, pos, edge_color=edge_colors, width=.5, alpha=.1)

# Crea leyendas para las categorías
legend_colors = [plt.Line2D([0], [0], color=color, lw=2, label=f'Categoría {cat}') for cat, color in color_map.items()]
plt.legend(handles=legend_colors)

"""##Componentes fuertemente conectados"""

strongly_connected_components = list(nx.strongly_connected_components(rutas))

sorted_components = sorted(strongly_connected_components, key=lambda component: sum(grados[node] for node in component), reverse=True)

for i, component in enumerate(sorted_components[:10], start=1):
    total_degree = sum(grados[node] for node in component)
    print(f"Top {i}: Componentes fuertemente conectados {component} - Grado: {total_degree}")

"""## Generación de Subgrafo

Se generará un subgrafo teniendo en cuenta a todas aquellas naves que pertenecen a la empresa analizada: MEDITERRANEAN SHIPPING COMPANY DEL PERU SAC.
"""

# Creamos una lista de nodos que pertenecen a la empresa "MSC"
nodos_msc = [nodo for nodo, datos in rutas.nodes(data=True) if 'empresa' in datos and datos['empresa'] == '3402- MEDITERRANEAN SHIPPING COMPANY DEL PERU SAC']

# Inicializamos un conjunto para almacenar los nodos adyacentes
nodos_incluidos = set()

# Iteramos sobre los nodos de la empresa "MSC"
for nodo in nodos_msc:
    # Agregamos el nodo y sus vecinos al conjunto de nodos adyacentes
    nodos_incluidos.add(nodo)
    vecinos = rutas.neighbors(nodo)
    for vecino in vecinos:
        nodos_incluidos.add(vecino)

# Agregamos también los nodos de origen de los nodos de la empresa "MSC"
for nodo in nodos_msc:
    for origen in rutas.predecessors(nodo):
        nodos_incluidos.add(origen)

# Extraemos el subgrafo que contiene los nodos de la empresa "MSC" y sus nodos adyacentes, así como los nodos de origen
rutas_msc = rutas.subgraph(nodos_incluidos)

# Nodos y aristas

nodos_msc = rutas_msc.number_of_nodes()
aristas_msc = rutas_msc.number_of_edges()

# Mostrar el número de nodos y aristas
print(f"Número de nodos: {nodos_msc}")
print(f"Número de aristas: {aristas_msc}")

"""Visualización del subgrafo"""

#Dibujamos el Grafo
total_naves = sum(1 for nodo, atributos in rutas_msc.nodes(data=True) if atributos.get("tipo") == "NAVE")
total_puertos = sum(1 for nodo, atributos in rutas_msc.nodes(data=True) if atributos.get("tipo") == "PUERTO")

print("Número de nodos en el grafo:", rutas_msc.number_of_nodes(), "(Naves: ",total_naves, ", Puertos: ",total_puertos, ")")
print("Número de bordes en el grafo:", rutas_msc.number_of_edges())

#Utilizar el diseno spring_layout para el parametro pos
pos = nx.spring_layout(rutas_msc)

plt.figure(figsize=(20,10))
plt.axis('off')

colores = ['red' if rutas_msc.nodes[nodo]['tipo'] == 'NAVE' else 'blue' for nodo in rutas_msc.nodes]
nx.draw_networkx_nodes(rutas_msc, pos, node_size=20, node_color=colores)
nx.draw_networkx_edges(rutas_msc, pos, alpha=.1)

plt.show()

"""##Aplicación de Métricas

###Métricas de centralidad
"""

#Utilizaremos esta funcion draw_net para la visualizacion de todas las redes
def draw_net(rutas, pos, measures, measure_name):
  pos = nx.spring_layout(rutas)
  plt.figure(figsize=(20,10))
  nodes = nx.draw_networkx_nodes(rutas, pos, node_size=20, cmap=plt.cm.plasma,
                                 node_color=list(measures.values()),
                                 nodelist=measures.keys())
  edges = nx.draw_networkx_edges(rutas, pos, alpha=.1)
  plt.title(measure_name)
  plt.colorbar(nodes)
  plt.axis('off')
  plt.show()

"""####Grados de Centralidad"""

grados = dict(nx.degree(rutas, weight='weight')) #calcular los grados como diccionario

#Valoracion segun el grado
ranks = [(k,v) for k,v in sorted(grados.items(), key=lambda item:item[1], reverse=True)]
ranks[:5] #top 5 según grado

#Visualizacion
draw_net(rutas, pos, grados, 'Degree Centrality - Centralidad de Grado')

"""####Centralidad de la cercanía"""

#calcular la centralidad de cercanía de todos los nodos
closeness = nx.closeness_centrality(rutas, distance='weight')

#top 5 de nodos según cercanía
ranks = [(k,v) for k,v in sorted(closeness.items(), key=lambda item:item[1], reverse=True)]
ranks[:5]

draw_net(rutas, pos, closeness, 'Closeness Centrality - Centralidad de Cercania')

"""####Centralidad de intermediación"""

#calcular la centralidad de intermediario de todos los nodos
betweeness = nx.betweenness_centrality(rutas, weight='weight')

#top 5 de nodos según la centralidad de intermediario
ranks = [(k,v) for k,v in sorted(betweeness.items(), key=lambda item:item[1], reverse=True)]
ranks[:5]

draw_net(rutas, pos, betweeness, 'Betweeness Centrality - Centralidad de Intermediacion')

"""####Centralidad armónica"""

#caclular la centralidad harmónica para todos los nodos
harmonic = nx.harmonic_centrality(rutas)

#top 5 de nodos según la centralidad harmónica
ranks = [(k,v) for k,v in sorted(harmonic.items(), key=lambda item:item[1], reverse=True)]
ranks[:5]

draw_net(rutas, pos, harmonic, 'Harmonic Centrality - Centralidad Armónica')

"""####Centralidad del vector propio"""

#caclular la centralidad harmónica para todos los nodos
eigenvector = nx.eigenvector_centrality(rutas, weight='weight')

#Valoracion segun el grado
ranks = [(k,v) for k,v in sorted(eigenvector.items(), key=lambda item:item[1], reverse=True)]
ranks[:5] #top 5 según grado

#Visualizacion
draw_net(rutas, pos, eigenvector, 'Centralidad del vector propio - Eigenvector centrality')

"""###Propiedades de Small World

Para ver si el grafo tiene propiedades de mundo pequeño, se utilizará la metodología en donde el se comparará el coeficiente de mundo pequeño del grafo en cuestión y un grafo aleatorio con la misma cantidad de nodos y aristas. Dicho coeficiente de mundo pequeño representa la proporción entre la longitud promedio de los caminos más cortos y el promedio de los caminos más cortos en un grafo aleatorio.
"""

#Creamos el Grafo no dirigido
rutas_nd = nx.Graph()

#Añadir los nodos
for index, row in nodos_df.iterrows():
    rutas_nd.add_node(row['id'], nodo=row['nodo'], tipo=row['tipo'], manif=row['manifiestos'], empresa=row['empresa'])

#Añadir las aristas
for index, row in edges_df.iterrows():
    source = row['id_ini']
    target = row['id_fin']
    containers = row['containers']
    viajes = row['viajes']
    peso = row ['conxviaj']

    rutas_nd.add_edge(source, target, weight=conxviaj, containers=containers, viajes=viajes,)

# a. ¿Cuántos puertos y viajes están representados en el grafo?

nodos = rutas_nd.number_of_nodes()
aristas = rutas_nd.number_of_edges()

# Mostrar el número de nodos y aristas
print(f"Número de puertos: {nodos}")
print(f"Número de viajes: {aristas}")

nx.is_directed(rutas_nd)

# Calcula el coeficiente de mundo pequeño del grafo
world_smallness = nx.algorithms.smallworld.sigma(rutas_nodir)

# Crea un grafo aleatorio con la misma cantidad de nodos y aristas
random_graph = nx.gnm_random_graph(len(rutas_nodir.nodes), len(rutas_nodir.edges))

# Calcula el coeficiente de mundo pequeño del grafo aleatorio
random_world_smallness = nx.algorithms.smallworld.sigma(random_graph)

# Imprime los resultados
print("Coeficiente de mundo pequeño del grafo:", world_smallness)
print("Coeficiente de mundo pequeño del grafo aleatorio:", random_world_smallness)

"""###Creación de Grafo Aleatorio"""

n = len(list(rutas_nd.nodes()))
pstar = np.log(n)/n

pstar

# Parámetros del modelo Erdős-Rényi
p = 0.001  # Probabilidad de conexión entre cualquier par de nodos

#Lista de nodos de g_newyork
nodos_rutas = list(rutas.nodes())

# Crear un grafo aleatorio utilizando el modelo Erdős-Rényi
grafo_aleatorio1 = nx.erdos_renyi_graph(len(nodos_rutas), p)

# Comparar algunas medidas de red entre tu grafo existente y el grafo aleatorio
print("Medidas de red para el grafo existente:")
print("Número de nodos:", len(rutas_nd.nodes()))
print("Número de aristas:", len(rutas_nd.edges()))

print("\nMedidas de red para el grafo aleatorio:")
print("Número de nodos:", len(grafo_aleatorio1.nodes()))
print("Número de aristas:", len(grafo_aleatorio1.edges()))
print("Grafo de rutas con p=0.001 es conectado?: ", nx.is_connected(grafo_aleatorio1))

#Visualizacion del grafo aleatorio p=0.001
plt.figure(figsize=(20,10))
plt.axis('off')

nx.draw_networkx(grafo_aleatorio1, node_size=20)

plt.title('Grafo Aleatorio rutas y p=0.001')

# Parámetros del modelo Erdős-Rényi
p = 0.005  # Probabilidad de conexión entre cualquier par de nodos

# Crear un grafo aleatorio utilizando el modelo Erdős-Rényi
grafo_aleatorio2 = nx.erdos_renyi_graph(len(nodos_rutas), p)

# Comparar algunas medidas de red entre tu grafo existente y el grafo aleatorio
print("Medidas de red para tu grafo existente:")
print("Número de nodos:", len(rutas_nd.nodes()))
print("Número de aristas:", len(rutas_nd.edges()))

print("\nMedidas de red para el grafo aleatorio:")
print("Número de nodos:", len(grafo_aleatorio2.nodes()))
print("Número de aristas:", len(grafo_aleatorio2.edges()))
print("Grafo de rutas con p=0.005 es conectado?: ", nx.is_connected(grafo_aleatorio2))

#Visualizacion del grafo aleatorio p=0.005
plt.figure(figsize=(20,10))
plt.axis('off')

nx.draw_networkx(grafo_aleatorio2, node_size=20)

plt.title('Grafo Aleatorio rutas y p=0.005')

# Parámetros del modelo Erdős-Rényi
p = 0.02  # Probabilidad de conexión entre cualquier par de nodos

# Crear un grafo aleatorio utilizando el modelo Erdős-Rényi
grafo_aleatorio3 = nx.erdos_renyi_graph(len(nodos_rutas), p)

# Comparar algunas medidas de red entre tu grafo existente y el grafo aleatorio
print("Medidas de red para tu grafo existente:")
print("Número de nodos:", len(rutas_nd.nodes()))
print("Número de aristas:", len(rutas_nd.edges()))

print("\nMedidas de red para el grafo aleatorio:")
print("Número de nodos:", len(grafo_aleatorio3.nodes()))
print("Número de aristas:", len(grafo_aleatorio3.edges()))
print("Grafo de rutas con p=0.02 es conectado?: ", nx.is_connected(grafo_aleatorio3))

#Visualizacion del grafo aleatorio p=0.005
plt.figure(figsize=(20,10))
plt.axis('off')

nx.draw_networkx(grafo_aleatorio3, node_size=20)

plt.title('Grafo Aleatorio rutas y p=0.02')

"""##Comportamiento del los grafos aleatorios

En el grafo, cuando la probabilidad de conexión entre dos nodos es menor que 0.005, esto quiere decir que es poco probable que exista un componente gigante en el grafo. Por otro lado, cuando la probabilidad de conexión es mayor que  0.005, es probable que exista un componente gigante en el grafo.

En el caso de p=0.001:

Ya que el valor p es menor al crítico que ha sido calculado, se estima que es probable que existan nodos no conectados y/o componentes pequeños.

Debido a que la probabilidad de conexión es baja y menor al valor crítico, la densidad de conexiones en el grafo será baja en comparación con otros grafos aleatorios con valores de conexión superiores al valor crítico.

En el caso de p=0.02:

Ya que el valor es alto y muy superior al valor crítico, es muy probable que el grafo tenga un componente gigante. Esto significa que la mayoría de los nodos estarán conectados de alguna manera directa o indirectamente.

En ese sentido, habrá una alta probabilidad de conexión entre nodos implica que la mayoría de los pares de nodos estarán conectados entre sí. En consecuencia, la densidad de conexiones en el grafo será alta en comparación con un grafo con un valor de conexión más bajo.

Finalmente, ya debido al alto nivel de conexión entre nodos del grafo, es probable que existan caminos cortos entre la mayoría de los nodos. Esto podría hacer que el grafo tenga un alto nivel de conectividad y no existan distancias tan lagas entre nodos.

Por otro lado, al visualizar el grafo con el valor p similar el p* (0.005), se puede observar que hay una diferencia significativa en el número de aristas, por lo que se peude concluir que el grafo aleatorio no tiene el mismo comportamiento que la red inicial.

##Agrupamiento de la red

Se calculará el agrupamiento de la red, primero se calculará el coeficiente de agrupamiento de cada nodo y luego se calculará el coeficiente de agrupamiento promedio de la red.
"""

# Calcular el coeficiente de agrupamiento para cada nodo
clustering_coefficients = nx.clustering(rutas_nd)

# Calcular el coeficiente de agrupamiento promedio de la red
average_clustering_coefficient = nx.average_clustering(rutas_nd)

print("Coeficiente de agrupamiento para cada nodo:")
print(clustering_coefficients)
print("\nCoeficiente de agrupamiento promedio de la red:")
print(average_clustering_coefficient)

nx.density(rutas)

"""##Pagerank"""

#Calculo del Pagerank
pagerank = nx.pagerank(rutas, weight='weight')

pagerank_ordenado = [(k,v) for k,v in sorted(pagerank.items(), key=lambda item:item[1], reverse=True)]
#print(pagerank_ordenado)
# top 10 nodos
print("10 nodos principales de acuerdo al Pagerank")
pagerank_ordenado[:10]

"""##Calculo de comunidades"""

!pipistall powerlaw
!pip install cdlib

from cdlib import algorithms
from cdlib import viz
from cdlib import evaluation

louvain_com = algorithms.louvain(rutas_nd, weight='weight')

print('La cantidad de comunidades es {}'.format(len(louvain_com.communities)))
for c in louvain_com.communities:
  print(c)

#mostrar la modularidad general
print(louvain_com.modularity_density())
#mostrar la modularidad de cada comunidad
print(louvain_com.internal_edge_density(summary=False))

viz.plot_network_clusters(rutas_nd, louvain_com, node_size=20, figsize=(20,10))
plt.show()

# Calcular la centralidad de intermediación ponderada para cada arista
edge_betweenness = nx.edge_betweenness_centrality(rutas, weight='weight')

# Ejecutar el algoritmo de Girvan-Newman con enlaces ponderados
communities = girvan_newman(rutas, most_valuable_edge=lambda edge: edge_betweenness[edge])

# Imprimir el número de comunidades detectadas
print("Número de comunidades detectadas:", len(list(communities)))